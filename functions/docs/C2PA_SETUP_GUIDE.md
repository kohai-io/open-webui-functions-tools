# C2PA Content Provenance Setup Guide for nano_banana_pro.py

This guide explains how to set up C2PA content provenance signing for AI-generated images in the Gemini 3 Pro Image pipeline.

## What is C2PA?

C2PA (Coalition for Content Provenance and Authenticity) adds cryptographic signatures and tamper-evident metadata to images, proving:
- **Origin**: This image was generated by AI using Gemini 3 Pro
- **Creator**: Who generated it (Open WebUI user)
- **Prompt**: What prompt was used (embedded in metadata)
- **Training Policy**: Whether the image can be used for AI training (default: "notAllowed")
- **Authenticity**: Any edits to the image will break the signature

## Installation

### 1. Install c2pa-python Library

Activate your Open WebUI conda environment:

```bash
conda activate openwebui
pip install c2pa-python
```

### 2. Download SDK Test Certificates (Development Only)

**IMPORTANT**: Self-signed certificates don't work with C2PA! Use the official SDK test certificates.

```bash
# Navigate to certificates directory
cd c:\Users\Robert\dev\AI\open-webui\open-webui

# Create certificates directory
mkdir certs
cd certs

# Download official test certificates from c2pa-python repository
# ES256 (Elliptic Curve) - Recommended
curl -O https://raw.githubusercontent.com/contentauth/c2pa-python/main/tests/fixtures/es256_certs.pem
curl -O https://raw.githubusercontent.com/contentauth/c2pa-python/main/tests/fixtures/es256_private.key

# Verify files were downloaded
ls -la
```

You should now have:
- `es256_certs.pem` (test certificate from C2PA SDK)
- `es256_private.key` (test private key from C2PA SDK)

**Note**: These test certificates will show a warning "issuer couldn't be recognized" but will work for development. For production, you need CA-signed certificates.

### 3. Configure nano_banana_pro.py Pipeline

1. **Open Open WebUI** in your browser
2. Go to **Workspace → Functions**
3. Find **"Gemini 3 Pro Image"** pipeline
4. Click to edit/configure

You have **two options** for providing certificates and keys:

#### **Option A: Paste Certificate/Key Content (Recommended - More Secure)**

Paste the actual certificate and key content into the encrypted fields. This is more secure as the content is encrypted in the database.

```bash
# Read certificate content
cat c:\Users\Robert\dev\AI\open-webui\open-webui\certs\es256_certs.pem
# Copy the output (including -----BEGIN CERTIFICATE----- and -----END CERTIFICATE-----)

# Read key content
cat c:\Users\Robert\dev\AI\open-webui\open-webui\certs\es256_private.key
# Copy the output (including -----BEGIN PRIVATE KEY----- and -----END PRIVATE KEY-----)
```

Then configure these valves:

| Valve | Value | Description |
|-------|-------|-------------|
| **ENABLE_C2PA_SIGNING** | `true` | Enable C2PA signing |
| **C2PA_CERT_CONTENT** | *Paste full certificate content* | Certificate PEM content (will be encrypted) |
| **C2PA_KEY_CONTENT** | *Paste full private key content* | Private key PEM content (will be encrypted) |
| **C2PA_TSA_URL** | *(leave empty for testing)* | Timestamp authority (optional) |
| **C2PA_TRAINING_POLICY** | `notAllowed` | AI training policy |

#### **Option B: Use File Paths**

Provide paths to the certificate and key files. Note: The Open WebUI process must have read access to these files.

| Valve | Value | Description |
|-------|-------|-------------|
| **ENABLE_C2PA_SIGNING** | `true` | Enable C2PA signing |
| **C2PA_CERT_PATH** | `C:\Users\Robert\dev\AI\open-webui\open-webui\certs\es256_certs.pem` | Full path to certificate |
| **C2PA_KEY_PATH** | `C:\Users\Robert\dev\AI\open-webui\open-webui\certs\es256_private.key` | Full path to private key |
| **C2PA_TSA_URL** | *(leave empty for testing)* | Timestamp authority (optional) |
| **C2PA_TRAINING_POLICY** | `notAllowed` | AI training policy |

> **Note**: If you provide both content AND path, the **content takes precedence**.

### 4. Enable Debug Mode (Recommended for Testing)

Set `debug: true` in the pipeline valves to see C2PA signing activity in logs.

## Testing

### 1. Generate an Image

In Open WebUI chat:
```
Generate a photo of a red apple on a white table
```

### 2. Check Logs

You should see debug messages like:
```
[DEBUG] Signing image with C2PA (size: 245678 bytes)
[DEBUG] C2PA signing successful! Manifest URI: self#jumbf=c2pa/...
[DEBUG] Signed image size: 248912 bytes (original: 245678 bytes)
```

### 3. Verify C2PA Manifest

Download the generated image, then use the c2pa command-line tool:

```bash
# Install c2pa-tool (if not already installed)
pip install c2pa-tool

# Check manifest
c2pa-tool path/to/downloaded_image.jpg

# Or get detailed JSON output
c2pa-tool path/to/downloaded_image.jpg --output json > manifest.json
```

Expected output should show:
- ✅ **AI-Generated** assertion
- ✅ **Training/Mining Policy**: notAllowed
- ✅ **Creator** information (your Open WebUI user)
- ✅ **Generator**: gemini-3-pro-image-preview
- ✅ **Prompt**: Your original prompt

### 4. Visual Verification

You can also use browser-based viewers:
- **Content Credentials Verify**: https://contentcredentials.org/verify
- Upload your signed image to see the manifest visually

## Training Policy Options

The `C2PA_TRAINING_POLICY` valve controls the `c2pa.training-mining` assertion:

| Value | Meaning |
|-------|---------|
| `notAllowed` | **Default** - Prohibit AI training/inference/data mining |
| `allowed` | Permit AI training and reuse |
| `constrained` | Allow with specific constraints (requires additional config) |

## Production Setup

For production deployments, you should:

### 1. Get a Proper Certificate

Options:
- **Adobe Content Authenticity Initiative**: https://contentauthenticity.org/
- **Commercial CA** (DigiCert, GlobalSign, etc.)
- **AWS Certificate Manager** (if using AWS KMS for signing)

### 2. Add Timestamp Authority

Timestamps prove when the image was signed. Add a TSA URL:

```
C2PA_TSA_URL: http://timestamp.digicert.com
```

Common TSA URLs:
- DigiCert: `http://timestamp.digicert.com`
- Sectigo: `http://timestamp.sectigo.com`
- FreeTSA: `https://freetsa.org/tsr`

### 3. Secure Private Keys

**CRITICAL**: Private keys should NEVER be stored in plain text or in the database!

Options:
- **Environment variables**: Set key path via env var
- **Hardware Security Modules (HSM)**: AWS KMS, Azure Key Vault
- **File permissions**: `chmod 600 c2pa_key.pem` (read-only by owner)

### 4. Certificate Chain

For production, you'll need the full certificate chain:

```
C2PA_CERT_PATH: /path/to/cert_chain.pem
```

Where `cert_chain.pem` contains:
```
-----BEGIN CERTIFICATE-----
[Your certificate]
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
[Intermediate CA certificate]
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
[Root CA certificate]
-----END CERTIFICATE-----
```

## Troubleshooting

### "C2PA library not installed"

**Solution**: Install c2pa-python
```bash
pip install c2pa-python
```

### "C2PA certificate not found"

**Solution**: Check the file path is absolute and correct
```bash
# Windows
C:\Users\Robert\dev\AI\open-webui\open-webui\certs\c2pa_cert.pem

# Linux/Mac
/home/user/open-webui/certs/c2pa_cert.pem
```

### "C2PA signing failed: Invalid signature"

**Possible causes**:
- Certificate and key don't match
- Wrong algorithm (try `es256` instead of `ps256`)
- Corrupted certificate file

**Solution**: Regenerate certificates

### "C2PA signing failed: the certificate was self-signed"

**Problem**: You're using OpenSSL-generated self-signed certificates, which don't work with C2PA SDK

**Solution**: Download and use the official SDK test certificates
```bash
cd c:\Users\Robert\dev\AI\open-webui\open-webui\certs
curl -O https://raw.githubusercontent.com/contentauth/c2pa-python/main/tests/fixtures/es256_certs.pem
curl -O https://raw.githubusercontent.com/contentauth/c2pa-python/main/tests/fixtures/es256_private.key
```

Then paste the certificate and key content into Open WebUI pipeline settings.

### "C2PA signing failed: invalid ES256 private key: expecting 'PRIVATE KEY'"

**Problem**: Your key is in the wrong format (EC PRIVATE KEY vs PRIVATE KEY)

**Solution**: Use the SDK test certificates (already in correct PKCS#8 format)

If you must use your own keys, convert to PKCS#8:
```bash
openssl pkcs8 -topk8 -nocrypt -in old_key.pem -out new_key.pem
```

### "C2PA signing successful but no manifest visible"

**Possible causes**:
- Image was re-encoded (JPEG quality change strips manifest)
- Image was edited (breaks signature)

**Solution**: Download directly from Open WebUI, don't screenshot or re-save

## Advanced: Custom Assertions

You can add custom assertions by modifying `_create_c2pa_manifest()` in `nano_banana_pro.py`:

```python
# Add custom assertion
manifest["assertions"].append({
    "label": "com.yourcompany.custom",
    "data": {
        "workflow_id": "image-gen-123",
        "cost": 0.05,
        "custom_field": "value"
    }
})
```

## Security Best Practices

1. ✅ **Prefer content fields over file paths** - Use `C2PA_CERT_CONTENT` and `C2PA_KEY_CONTENT` for better security (encrypted in database)
2. ✅ **Never commit private keys** to git repositories or expose in logs
3. ✅ **Use strong passphrases** for private keys (production)
4. ✅ **Rotate certificates** regularly (yearly recommended)
5. ✅ **Restrict file permissions** on key files (if using path method): `chmod 600 *.pem`
6. ✅ **Use timestamp authorities** for non-repudiation in production
7. ✅ **Monitor signing failures** in production logs
8. ✅ **Delete local key files** after pasting content into Open WebUI (if using content method)

## References

- **C2PA Specification**: https://c2pa.org/specifications/specifications/1.3/index.html
- **C2PA Python Library**: https://github.com/contentauth/c2pa-python
- **Content Credentials**: https://contentcredentials.org/
- **Adobe CAI**: https://contentauthenticity.org/

## Next Steps

Once C2PA is working in `nano_banana_pro.py`, you can:
1. **Expand to other pipelines** (ComfyUI, DALL-E, etc.)
2. **Add platform-wide signing** in `routers/images.py`
3. **Create verification endpoint** to check uploaded images
4. **Add UI indicators** for C2PA-signed images
5. **Integrate with Content Credentials Verify**
